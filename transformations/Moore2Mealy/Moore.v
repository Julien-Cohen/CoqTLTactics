

(********************************************************************
	@name Coq declarations for metamodel: <Moore>
	@date 2022/01/29 12:14:47
	@description Automatically generated by Ecore2Coq transformation.
 ********************************************************************)

(* Coq libraries *)
Require Import String.
Require Import Bool.
Require Import List.      (* sequence *)
Require Import Multiset.  (* bag *)
Require Import ListSet.   (* set *)
Require Import PeanoNat.
Require Import EqNat.
Require Import Coq.Logic.Eqdep_dec.
Scheme Equality for option. (* equality for option type *)

From core Require Import 
  utils.Utils
  Metamodel
  modeling.ModelingMetamodel
  Model
  utils.CpdtTactics
  Tactics.

(* Base types *)


Record State : Set :=
  BuildState 
  {  name : string ;
     output : string 
  }.

Record Transition : Set :=
  BuildTransition { input : string }.



Record TransitionSource : Set :=
  BuildTransitionSource 
    { s_tr : Transition ;
      s_st : State 
    }.

Definition maybeBuildTransitionSource (tr_arg: Transition) (so_arg: option (State)) : option TransitionSource :=
  match tr_arg, so_arg with
  | tr_arg_succ, Some so_arg_succ => Some (BuildTransitionSource tr_arg_succ so_arg_succ)
  | _, _ => None
  end.

Record TransitionTarget : Set :=
   BuildTransitionTarget 
   { t_tr : Transition ;
     t_st : State 
   }.

Definition maybeBuildTransitionTarget (tr_arg: Transition) (ta_arg: option (State)) : option TransitionTarget :=
  match tr_arg, ta_arg with
  | tr_arg_succ, Some ta_arg_succ => Some (BuildTransitionTarget tr_arg_succ ta_arg_succ)
  | _, _ => None
  end.



(* Accessors *)

Definition beq_State (st_arg1 : State) (st_arg2 : State) : bool :=
  ( beq_string st_arg1.(name) st_arg2.(name) ) 
  &&  ( beq_string st_arg1.(output) st_arg2.(output) )
.

Definition beq_Transition (tr_arg1 : Transition) (tr_arg2 : Transition) : bool :=
  beq_string tr_arg1.(input) tr_arg2.(input)
.


(* Meta-types (or kinds, to be used in rules) *)	

Inductive ElementKind : Set :=
  | State_K
  | Transition_K
.

Definition getTypeByEKind (mocl_arg : ElementKind) : Set :=
  match mocl_arg with
    | State_K => State
    | Transition_K => Transition
  end.	

Inductive LinkKind : Set :=
    | TransitionSource_K
    | TransitionTarget_K
.

Definition getTypeByLKind (more_arg : LinkKind) : Set :=
  match more_arg with
  | TransitionSource_K => TransitionSource
  | TransitionTarget_K => TransitionTarget
  end.

(* used ? *)
Definition getERoleTypesByLKind (more_arg : LinkKind) : Set :=
  match more_arg with
  | TransitionSource_K => (Transition * State)
  | TransitionTarget_K => (Transition * State)
  end.

(* Data types *)			
Inductive Element : Set :=
  | StateElement : State -> Element
  | TransitionElement : Transition ->Element. 


Definition beq_Element (c1 : Element) (c2 : Element) : bool :=
  match c1, c2 with
  | StateElement o1, StateElement o2 => beq_State o1 o2
  | TransitionElement o1, TransitionElement o2 => beq_Transition o1 o2
  | _, _ => false
  end.

Inductive Link : Set :=
  | TransitionSourceLink : TransitionSource -> Link
  | TransitionTargetLink : TransitionTarget -> Link.


(* FIXME *)
Definition beq_Link (l1 : Link) (l2 : Link) : bool := true.

(* Reflective functions *)
Lemma MooreMetamodel_eqEClass_dec : 
 forall (mocl_arg1: ElementKind) (mocl_arg2: ElementKind), { mocl_arg1 = mocl_arg2 } + { mocl_arg1 <> mocl_arg2 }.
Proof. repeat decide equality. Defined.

Lemma MooreMetamodel_eqEReference_dec : 
 forall (more_arg1: LinkKind) (more_arg2: LinkKind), { more_arg1 = more_arg2 } + { more_arg1 <> more_arg2 }.
Proof. repeat decide equality. Defined.

(* not used *)
Definition getEKind (moob_arg : Element) : ElementKind :=
   match moob_arg with
   | StateElement _ => State_K
   | TransitionElement _ => Transition_K
   end.

(* not used *)
Definition getLKind (moli_arg : Link) : LinkKind := 
  match moli_arg with
  | TransitionSourceLink _  => TransitionSource_K
  | TransitionTargetLink _  => TransitionTarget_K
  end.



Definition get_E_Data (mocl_arg : ElementKind) (moob_arg : Element) : option (getTypeByEKind mocl_arg).
  destruct moob_arg ; destruct mocl_arg ; unfold getTypeByEKind.
  + exact (Some s).
  + exact None.
  + exact None.
  + exact (Some t).
Defined.

Definition get_L_Data (more_arg : LinkKind) (moli_arg : Link) : option (getTypeByLKind more_arg).
  destruct moli_arg ; destruct more_arg ; simpl.
  exact (Some t).
  exact None.
  exact None.
  exact (Some t).
Defined.


(* Generic functions *)

Definition Metamodel_Instance : Metamodel :=
  {|
    ElementType := Element;
    LinkType := Link;
    elements_eqdec := beq_Element ;
    links_eqdec := beq_Link
  |}.


Definition MooreModel := Model Metamodel_Instance.


Definition toElement (mocl_arg: ElementKind) (t: getTypeByEKind mocl_arg) : Element.  
  destruct mocl_arg.
  exact (StateElement t).
  exact (TransitionElement t).
Defined.
(* Personal Remark : I discover that it is easier to program interactively as above than writing the correct match cases because the match cases are generated by destruct. However, the effort falls on the reader. *) 


Definition toLink (more_arg: LinkKind) (t: getTypeByLKind more_arg) : Link.
  destruct more_arg.
  exact (TransitionSourceLink t).
  exact (TransitionTargetLink t).
Defined.




Fixpoint Transition_getSourceOnLinks (tr_arg : Transition) (l : list Link) : option (State) :=
  match l with
  | (TransitionSourceLink (BuildTransitionSource Transition_ctr source_ctr)) :: l' => 
      if beq_Transition Transition_ctr tr_arg 
      then Some source_ctr 
      else Transition_getSourceOnLinks tr_arg l'
  | _ :: l' => Transition_getSourceOnLinks tr_arg l'
  | nil => None
end.

Definition Transition_getSource (tr_arg : Transition) (m : MooreModel) : option (State) :=
  Transition_getSourceOnLinks tr_arg m.(modelLinks).
  
Definition Transition_getSourceObject (tr_arg : Transition) (m : MooreModel) : option (Element) :=
  match Transition_getSource tr_arg m with
  | Some st_arg => Some (StateElement st_arg) 
  | None => None
  end.

Fixpoint Transition_getTargetOnLinks (tr_arg : Transition) (l : list Link) : option (State) :=
  match l with
   | (TransitionTargetLink (BuildTransitionTarget Transition_ctr target_ctr)) :: l' => 
       if beq_Transition Transition_ctr tr_arg 
       then Some target_ctr 
       else Transition_getTargetOnLinks tr_arg l'
   | _ :: l' => Transition_getTargetOnLinks tr_arg l'
   | nil => None
  end.

Definition Transition_getTarget (tr_arg : Transition) (m : MooreModel) : option (State) :=
  Transition_getTargetOnLinks tr_arg m.(modelLinks).
  
Definition Transition_getTargetObject (tr_arg : Transition) (m : MooreModel) : option (Element) :=
  match Transition_getTarget tr_arg m with
  | Some st_arg => Some (StateElement st_arg) 
  | None => None
  end.


(* Typeclass Instances *)	
#[export]
Instance ElementDenotation : Denotation Element ElementKind :=
  {
	denoteDatatype := getTypeByEKind;
	unbox := get_E_Data ;
	constructor := toElement;
  }.

#[export]
Instance LinkDenotation : Denotation Link LinkKind :=
  {
	denoteDatatype := getTypeByLKind ;
	unbox := get_L_Data ;
	constructor := toLink;
  }.


#[export]
Instance ModelingMetamodel_Instance : 
	ModelingMetamodel Metamodel_Instance :=
  { 
    elements := ElementDenotation;
    links := LinkDenotation; 
  }.

